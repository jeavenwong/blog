---
title: 简单四则运算解释器的实现
date: 2020-05-06 12:18:56
tags: 
	- 编译原理
	- 词法分析
	- 语法分析
---

#### 起因

以前简单学过编译原理的理论知识，但是由于太过抽象，平时用到的机会也不多，所以很多都遗忘了，为了能简单拾起一些最最基本的知识，于是决定写一个 Lexer 程序和 Parser程序。

<!--more-->

#### 前言

**词法分析**:
所谓的词法分析，就是把输入的文本(源代码)中每一个单独的字符(词素)组装成一个个单词token(语素)，这些token里可以有表示符id，标点符号，保留字，运算符等。这个过程是通过正则表达式来完成的。而词法分析器在具体的编程实现上可以先写正则表达式，然后用抽象的正则表达式来转换为nfa，再从nfa转换为dfa，实现中就使用dfa来实现分词。当然也可以直接使用高级语言的正则表达式功能，每个token都写一个正则表达式，排列匹配的正则表达式的优先级，然后每次加一长度对字符串进行匹配，但这样的话，效率可能不如直接写dfa高，所以一般词法分析都是自己人工通过预先设定的保留字，id，运算符，标点符号等词来构建dfa(确定有穷自动机)，其中涉及到的算法就是 RE -> NFA -> DFA 的转换算法。正则表达式引擎就是用nfa/dfa来实现的。

**语法分析**:
一般文法按照表达能力接近自然语言的程度，可以分为正则文法，上下文无关文法(cfg)，上下文有关文法(csg)，递归可枚举文法。现在大多数的编程语言都是上下文有关语法(全局变量)，但语法分析的时候都使用上下文无关文法来进行分析。语法分析的输入就是词法分析得到的token序列，通过自己构造的上下文无关文法来对token序列进行语法分析。有两种思路，第一种分析思路是从顶向下分析，即推导，即从非终结符开始推导，看看能不能根据规定的文法从非终结符推导出给定的句子，如果可以推导出那就是符合规定的文法，这个句子就是语法正确的。这个自顶向下分析的过程可以基于数据表驱动来进行分析，也可以使用简单粗暴的递归下降法进行分析，本质都是基于栈的分析。第二种分析思路是，从底向上分析，即规约，看看是否可以由句子来根据规定的文法来规约到非终结符。一般，parser的具体实现中，第一种思路实现起来更加方便快速，所以现在大多数的编程语言的语法分析都是自顶向下分析的。第一种中比较简单也最常用的就是使用LL(1)型文法来进行语法分析，c语言就使用可回溯的LL(1)型文法进行分析，但LL(1)要求一般不能出现左递归。如果第二种的话，常用的是LR型文法及算法，如果第一种思路无法解决语法分析的话就使用LR算法。一般来说，语法分析可以一边分析一边递归的构造出每个ast节点，最终分析结束可以得到一颗ast(抽象语法树)。之后，可以直接对ast解释执行，也可以通过ast生成中间表示IR，前者做法简单快速但速度效率可能较慢，后者做法就是解释器常见的做法，IR一般可以是字节码，比如java的字节码，然后由jvm解释执行。

**语义分析:**
对上一步语法分析得到的ast进行分析，做一些操作，比如类型检查等。验证符合语法的句子是否符合上下文语义。

**代码优化:**
可以省去，大概是可以根据代码对一些冗余或者重复的代码进行优化，还有寄存器级别的优化等。

**代码生成:**
进行完语义分析后，根据ast可以进行递归下降生成到目标语言，如果直接生成机器语言，那需要对二进制格式以及寄存器很熟。

**自动分析工具**:
主语言是java，可以玩一下antlr。

#### 闲话

其实在学习生活过程中遇到编译知识的几率还是蛮高的（除了专业编译器研究人员和使用词法语法分析的工具外），比如，正则表达式，DFA（确定的有穷自动机）这些在一些常见算法（如KMP算法）里都多多少少会有所体现。再比如，在笔者本科的时候，数电里很经典的有穷状态机（FSM）其实就是 DFA，还有用 Verilog HDL 写 FPGA 的实验中经常需要自己构建有穷的状态，这也是 DFA 的应用。正则表达式就不用提了，应用就太广了，相信没有人没有接触过 RE（正则表达式）。

为了简单起见，使用正则表达式来做字符串中关键字的匹配，以及使用 DFA 来分析词素构建 token 语素。词法分析结束之后我会选择 CFG（上下文无关语法）中最常见最简单的没有左递归的 LL(1) 型文法来做语法分析，做法尽可能的简单，可以选择直接基于数据表来做，也可能会使用递归下降法来做解析。语法分析结束可以输出一个语法分析树。

知乎某位大佬曾经说过，如果一个程序员不是专门做编译器的开发工作，那他 对编译原理主要掌握以下几点就够用了：词法分析方面，掌握正则表达式，了解dfa/nfa。Parsing 方面，能读懂 BNF，知道AST，会写简单的递归下降 parser，会用 antlr 之类的 parser generator。 优化方面，知道现代编译器的优化能力有多强，知道如何配合编译器写出高效易读的代码，避免试图outsmart编译器。会实现简单的虚拟机（stack-based，不带GC），并把四则运算表达式翻译为虚拟机指令。
ANTLR是一个神器，关于ANTLR的入门教程：
[https://www.cntofu.com/book/115/readme.html](https://www.cntofu.com/book/115/readme.html)

#### 实现

实现了一个四则运算的解释器，即仅支持 + - * / 等四个二元运算符，然后不支持定义变量，支持数字，包括浮点数和整数。 

#### 内容

##### 词法分析

词法分析使用的是正则文法，也就是正则表达式，所以先写出需要使用的正则表达式，然后再根据正则表达式构造出 NFA ，之后再将NFA转化为 DFA ，依据  DFA  进行状态机的编码，就可以读入输入文件进行词法分析了。其实正则表达式构造 NFA 的算法是比较麻烦的，但是这里不支持保留字，标识符，标点符号等，所以分词比较简单，下面直接可以画出 DFA。

![DFA图示](DFA.jpg)

下面是词法分析程序的输入，也是整个程序的输入。

![词法分析程序输入](词法分析程序输入.jpg)

下面是词法分析程序的输出，即 token（语素） 序列。

![输出Token](tokens.jpg)

##### 语法分析

语法分析程序的输入是词法分析程序的输出，即 token 序列。

不考虑语法制导翻译的话，语法分析输出的都应该是一颗抽象语法树 AST ，这个结构比较抽象。下面我手画一个。

![AST结构图](AST.jpg)

语法分析中，最麻烦的莫过于构造 LL(1) 文法了，如下图所示。

![LL(1)文法构造](LL(1)文法构造.jpg)

语法分析中如果遇见语法错误会进行错误的提示，然后表明当前的代码是语法错误的，比如我刻意去掉上面输入的表达式中的右括号，程序结果如下图所示。

![语法错误](语法错误.jpg)

当语法分析正确后，表明我们的表达式是符合语法的，之后我们可以根据这颗 AST 来做任何操作，比如可以由前序遍历得到正序的token序列，后序遍历可以得到逆波兰表达式，可以用来模拟基于栈进行程序的执行。理论上，AST 可以转化为任何一种IR（中间表示），比如转化为 java 字节码，由 JVM 解释执行，也可以直接用 AST 解释执行。

最后就是用代码简单的模拟一下 Stack-Based VM （这类虚拟机的代表就是JVM），然后基于栈来执行指令代码，即用逆波兰表达式进和栈进行计算。

下图是 VM 程序执行指令的输出。

![运行结果](运行结果.jpg)

#### 感悟

我觉得整个过程中，写 DFA 来词法解析很死板，在实际中应该会基于正则表达式来进行 DFA 的生成，龙书那么复杂的过程其实也是用来写生成词法分析程序的工具。做语法分析的难点就是构造LL(1)文法，而且还得消除左递归，否则不能用递归下降法进行文法分析，还有更麻烦的语法分析的方法就是对语法进行Fisrt-Fellow集分析得到一个预测表（parser table），根据表来进行文法分析，输入是文法规则文件和表文件，相比较之下，递归下降法更加简单高效。这个项目非常简单，但作为简单实践下编译原理的理论知识还是可以的，麻雀虽小五脏俱全嘛。但是本项目其实只是做了编译器的前端，后端的代码优化和代码生成和汇编指令啥的对于我这样的后端程序员也很重要。

#### 源码

我将源代码放在了 gitee 上面，仓库链接如下。
[https://gitee.com/jeavenwong/SimpleJInterpreter](https://gitee.com/jeavenwong/SimpleJInterpreter)

我又基于 ANTLR 实现了四则运算的第二版，果然 ANTLR 这款 parser 生成器配合 Vistor 以及 Listener 两种 Parser Tree 的遍历方式很强大，还能够直接处理 LL(*) 文法的左递归。下面是第二版的源码仓库链接。
[https://gitee.com/jeavenwong/SimpleJInterpreterV2](https://gitee.com/jeavenwong/SimpleJInterpreterV2)  
